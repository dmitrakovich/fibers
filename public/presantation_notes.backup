1. Мой рассказ будет посвящен асинхронности, что это такое, зачем она нужна, как реализуется асинхронность в PHP и что нам дают файберы, которые появились в PHP 8.1

-----------------------------------------------------------------------------------------------------------------------------------

2. Для начала надо сказать пару слов о асинхронности и чем асинхронное выполнение отличается от синхронного.

При традиционном синхронном подходе код будет выполняться последовательно:
* Отправляем первый запрос.
* Ждём ответа.
* Отправляем второй запрос.
* Ждём ответа.

Здесь каждая операция блокирует поток выполнения. В большинстве случаев для PHP это нормально. Проблемы могут возникнуть только тогда, когда таких блокирующих вызовов много, а производительность для этой программы критична. Такая программа не будет использовать все доступные ей ресурсы, и бОльшую часть времени будет простаивать. Пока выполняются любых операций ввода / вывода (I/O), процессор (CPU) ничем не занят. И наоборот, когда процессор (CPU) вычисляет что-то сложное вся программа "замирает" и не отвечает на ввод.

-----------------------------------------------------------------------------------------------------------------------------------

3. В случае асинхронного подхода мы можем начать выполнение сразу нескольких задач, и при этом не нужно дожидаться окончания одной задачи, чтобы начать другую. И чем больше операций мы выполним асинхронно, тем быстрее отработает наша программа.

-----------------------------------------------------------------------------------------------------------------------------------

4. На этом моменте стоит упомянуть что асинхронность и параллелизм это не одно и тоже.

При конкурентном выполнении у нас две задачи могут запускаться, выполняться и завершаться в перекрывающиеся периоды времени. Это не означает, что обе они будут выполняться одновременно в один момент времени. Хорошей аналогией здесь может быть ваш компьютер. Когда у нас выполняются две программы на одноядерном CPU, то нет никакой возможности выполнять их параллельно. Им всё равно придётся как-то делить время CPU. Таким образом операционная система решает что нужно сначала запустить одну программу, затем другую. Или операционная система может сначала выполнить небольшую часть одной программы, а затем также небольшую часть другой. Вторая программа может начать выполняться раньше, чем выполнится первая.

Напротив, параллелизм - это когда две задачи выполняются буквально одновременно. Можно продолжить пример с компьютером и здесь представить многопоточную программу, которая выполняется на многоядерном процессоре. Параллельное выполнение требует соответствующего железа, которое способно выполнять сразу несколько задач одновременно. На одноядерном процессоре мы можем получить только конкурентное выполнение задач, но никак не параллельное. Параллелизм можно рассматривать как особый случай конкурентности, при котором задачи действительно выполняются одновременно.

Из всего этого можно сделать выводы, что приложение может выполняться конкурентно, но не параллельно. Это будет означать, что приложение выполняет сразу несколько задач, но никакие две задачи не выполняются одновременно.

-----------------------------------------------------------------------------------------------------------------------------------

5. Но вернёмся к PHP, который является однопоточным языком программирования. Это означает, что в один момент времени может выполняться только одна строчка PHP кода. Чтобы понять как это влияет на асинхронность для начала надо понять разницу между процессами и потоками.

Не важно на каком языке вы пишите, ваш код компилируется или интерпретируется в двоичный файл. Во время выполнения этого бинарного кода программе нужно получить от операционной системы некоторые ресурсы: адресное пространство в памяти, PID (идентификатор процесса) и другие. Может быть запущено несколько инстансов одной программы, каждый при этом будет отдельным процессом внутри операционной системы. Все процессы изолированы друг от друга. Каждый процесс считает себя единственным запущенным в операционной системе, и что больше никаких программ нет. Часто можно увидеть ситуацию, когда одна программа "зависает", но при этом из неё можно выйти, не оказывая влияния на другие запущенные программы.
Итак, процесс запускается, получает свою собственную память и остальные ресурсы. Все потоки внутри этого процесса делят эту память и ресурсы. У каждого процесса есть как минимум один основной поток выполнения. После того как этот поток заканчивает выполнение, сам процесс и программа завершаются. Процесс можно рассматривать как контейнер с бинарным кодом, памятью и другими ресурсами операционной системы.

Однопоточная конкурентность
Когда у нас есть несколько потоков внутри одного процесса, то можно сразу обрабатывать несколько задач одновременно. Более того, в большинстве случаев мы имеем системы с несколькими процессорами или многоядерными процессорами. Это позволяет реализовать конкурентность в наших программах.
Но, так же важно понимать, что конкурентное выполнение не означает многопоточность. В большинстве случаев однопоточный параллелизм - неплохое решение. Со всеми своими преимуществами потоков, многопоточные программы могут стать (и обязательно станут) неподдерживаемыми монстрами из кучи потоков. Да конечно, коммуникация между потоками достаточно быстрая и дешевая, но при этом нужно помнить, что проблема в одном потоке внутри процесса, может задеть все остальные потоки да и сам процесс (скажем привет синхронизации и дедлокам).
Производительность приложения зависит от того, насколько оптимально оно использует доступные ему ресурсы (CPU, память и другие). Некоторые операции в нашей программе могут потребовать значительного времени для завершения и в это время хотелось бы иметь возможность делать что-то ещё, а не просто ждать. Вот тут то нам и пригодится конкурентность. Давайте рассмотрим две основные причины, почему операции могут долго выполняться:
CPU-bound операции, которые требуют тяжелых вычислений. Они требуют процессорного времени.
I/O-bound операции, которые зависят от сети/оборудования/взаимодействия с пользователем. Они требуют просто времени: нужно дождаться определенного события.
При выполнении CPU-bound задачи поток выполнения блокируется из-за того, что он слишком активно используется. Например, когда нам нужно сделать какие-то сложные вычисления или отрендерить 3д модель. Для таких операций лучше всего подходит многопоточность. На многопроцессорных системах несколько потоков на самом деле могут параллельно проводить какие-то вычисления. Таким образом достигается более высокая общая производительность.
С другой стороны при выполнении I/O-bound операции поток выполнения блокируется потому что ему приходится ждать данные из источника ввода/вывода (сеть, жесткий диск и др.). Когда операционная система видит, что сейчас для этого потока нет никаких данных, то он переводится в "спящий режим". В таком состоянии поток не выполняется, он просто ждёт. И в данной ситуации многопоточность нам ничем не поможет. Ну создадим мы много потоков, которые будут ждать выполнения некоторого события. От этого само событие быстрее не произойдет.
А теперь поговорим о PHP. В большинстве случаев это язык для веб-приложений, где у нас очень много разного I/O: ходим в файловую систему, делаем сетевые запросы или обрабатываем команды в терминале. Исходя из этого однопоточный PHP не так уж и плох для реализации конкурентности, и что однопоточность в этом случае - не ограничение, а наоборот возможность.

-----------------------------------------------------------------------------------------------------------------------------------

6. При выполнении CPU-bound задачи поток выполнения блокируется из-за того, что он слишком активно используется. Например, когда нам нужно сделать какие-то сложные вычисления или отрендерить 3д модель. Для таких операций лучше всего подходит многопоточность. На многопроцессорных системах несколько потоков на самом деле могут параллельно проводить какие-то вычисления. Таким образом достигается более высокая общая производительность.
С другой стороны при выполнении I/O-bound операции поток выполнения блокируется потому что ему приходится ждать данные из источника ввода/вывода (сеть, жесткий диск и др.). Когда операционная система видит, что сейчас для этого потока нет никаких данных, то он переводится в "спящий режим". В таком состоянии поток не выполняется, он просто ждёт. И в данной ситуации многопоточность нам ничем не поможет. Ну создадим мы много потоков, которые будут ждать выполнения некоторого события. От этого само событие быстрее не произойдет.
А теперь поговорим о PHP. В большинстве случаев это язык для веб-приложений, где у нас очень много разного I/O: ходим в файловую систему, делаем сетевые запросы или обрабатываем команды в терминале. Исходя из этого однопоточный PHP не так уж и плох для реализации конкурентности, и что однопоточность в этом случае - не ограничение, а наоборот возможность.

-----------------------------------------------------------------------------------------------------------------------------------

7. PHP создавался с намерением всегда выполняться синхронно и быть блокирующим. Все нативные функции для работы с I/O в PHP блокируют поток выполнения.

-----------------------------------------------------------------------------------------------------------------------------------

8. Что делает такой клиент? Подключается к нашему SQL-серверу, переводит работу сокета в неблокирующий режим, пакует запрос в бинарный формат понятный SQL-серверу, записывает данные в сокет.

Так как сокет в неблокирующем режиме, то операция записи со стороны PHP выполняется быстро.

Но что вернется как результат такой операции? Мы не знаем, что ответит SQL-сервер. Он может долго выполнять запрос или не выполнить вообще. Но что-то же надо вернуть? Если мы используем PDO и вызываем update запроса на SQL-сервере, нам возвращается affected rows — количество строк измененных этим запросом. Это мы вернуть пока не можем, поэтому только обещаем возврат.

-----------------------------------------------------------------------------------------------------------------------------------

9. Promise

Это концепция из мира асинхронного программирования.
Promise — это объект-обертка над результатом асинхронной операции. При этом результат операции нам пока неизвестен.

Как работает Promise

Так как результата еще нет, мы можем установить только какие-то callbacks.

Когда данные будут доступны, необходимо выполнить колбэк onResolve.

Если произойдет ошибка, то выполнится колбэк onReject для обработки ошибки.

-----------------------------------------------------------------------------------------------------------------------------------

10. Когда у нас есть Promise, мы можем, например:

установить колбэк и получить те же affected rows, которые нам возвращает PDOConnection;
обработать ошибку, добавить в лог;
попытаться заново выполнить запрос, если SQL-сервер ответил ошибкой.

-----------------------------------------------------------------------------------------------------------------------------------

11. Остается вопрос: мы поставили колбэк, а кто будет вызывать resolve и reject?

Event Loop

Существует концепция Event Loop — цикл событий. Он умеет обрабатывать сообщения в асинхронной среде. Для асинхронного I/O это будут сообщения от ОС о том, что сокет готов к чтению или записи.

Как это работает.

Клиент сообщает Event Loop, что его интересует какой-то сокет.
Event Loop опрашивает ОС через системный вызов stream_select: готов ли сокет, все ли данные записались, пришли ли данные с другой стороны.
Если ОС сообщает, что сокет не готов, заблокирован, то Event Loop повторяет цикл.
Когда ОС оповещает о готовности сокета, Event Loop возвращает управление в клиент и разрешает (resolve или reject) Promise.

-----------------------------------------------------------------------------------------------------------------------------------

12. Существует несколько реализаций, на слайде представлены основные.

ReactPHP. Самый старый проект. Сейчас минимальная требуемая версия PHP 5.3.8. Проект реализует стандарт Promises/A из мира JavaScript.

AMPHP. Минимальное требование PHP 7.1. Здесь используются корутины поверх Promise.

Swoole. Это интересный китайский фреймворк, в котором разработчики пытаются перенести в PHP некоторые концепции из мира Go. Также есть реализация полноценного вебсервера.

REVOLT. Совместный проект Amp, ReactPHP. Для его работы требуется PHP 8.1 либо 8.0.7 с дополнительно установленными файберами (ext-fiber). Проект очень молодой, текущая на данный момент его версия 0.2.0. На русском языке статей по нему не нашел. Данный проект позиционирует себя как базовый набор инструментов для асинхронной работы с PHP (не фреймворк), лишенный недостатков Amp, ReactPHP, т.к. был написан с использованием фаберов, а не каким-то костыльным методом.

Еще стоит упомянуть про RoadRunner, но он не про асинхронность, он про долгоживущий PHP. Написан на Go.

Плюсы долгоживущего процесса:
Не тратится время на booting
Не тратится время на создание подключения к БД
Возможность использования in-memory кэша прямо в процессе


-----------------------------------------------------------------------------------------------------------------------------------

13. Сразу привожу список фреймворков и компонент, которые в том или ином виде реализовали асинхронность. Если честно, с этого списка знаю только 2, остальные первый раз вижу.

Laravel Octane ставил себе. При установке в нем нужно выбрать что будет использоваться в качестве веб сервера. На выбор Road Runner и Swoole.
Road Runner как я и говорил он позволяет 1 раз загрузить все сервис провайдеры, роуты, конфиги, создать подключение к базе данных, в общем загрузить все приложение и на нем уже прогонять все запросы от пользователей.
Swoole сделает по сути тоже самое, но во-первых не нужен go в качестве сервера, во вторых он еще дает возможность писать асинхронный код в приложении.

-----------------------------------------------------------------------------------------------------------------------------------

14. Посмотрим как будет выглядеть клиент с использованием ReactPHP для MySQL.
Все почти также, как мы написали: создаем Сonnection и выполняем запрос. Можем установить колбэк для обработки результатов (вернуть affected rows):
и колбэк для обработки ошибок:
1 параметр resolved. 2 rejected

Из этих колбэков можно строить длинные-длинные цепочки, потому что каждый результат then в ReactPHP также возвращает Promise.
Это решение проблемы, которая называется «callback hell». К сожалению, в реализации ReactPHP это приводит к проблеме «Promise hell», когда для корректного подключения RabbitMQ, требуется10-11 колбэков. Работать с таким кодом и исправлять его достаточно сложно.

-----------------------------------------------------------------------------------------------------------------------------------

15. Этот проект младше, чем ReactPHP, и продвигает иную концепцию — корутины. Если посмотреть на работу с MySQL в AMPHP, то видно, что это почти аналогично работе с PDOConnection в PHP.

Здесь мы создаем пул, подключаемся и выполняем запрос. Мы можем обрабатывать ошибки через привычные try...catch, нам не нужны колбэки.

Но перед асинхронным вызовом здесь появляется ключевое слово — yield.

Ключевое слово yield превращает нашу функцию в генератор, которая при вызове возвращает объект класса Generator.
У генератора есть интересная функция — мы можем снаружи отправить данные в генератор. В этом случае это уже не совсем генератор, а корутина или сопрограмма.

Кроме отправки данных в генератор можно отправлять ошибки и обрабатывать их изнутри, что удобно.
Подытожим. Корутина это компонент программы, который поддерживает остановку и продолжение выполнения с сохранением текущего состояния. Корутина помнит свой стек вызовов, данные внутри, и может их использовать в дальнейшем.

Посмотрим на интерфейсы генераторов и Promise. Они выглядят одинаково, за исключением разных названий методов. Мы можем отправить данные и выкинуть ошибку и в генератор, и в Promise.

-----------------------------------------------------------------------------------------------------------------------------------

16. Как-то так будет выглядеть асинхронный код на swoole. Если мы пишем код внутри асинхронного сервера, то оболочка Co\run не нужна, т.к. мы уже внутри нее. Функция go() возвращает идентификатор процесса, который я пока не понял зачем нужен. Для связи между разными корутинами, и управлении данными в них - используются каналы (chanels). Можем использовать WaitGroup для синхронизации нескольких корутин, дождаясь завершения нескольких корутин.

Вообще там очень огромный функционал, есть все необходимое для реализации асинхронности.

-----------------------------------------------------------------------------------------------------------------------------------

17. Fiber -  это единственный финальный класс, что предотвращает его расширение другим пользовательским классом. С помощью Fibers код внутри Fiber может приостановиться и вернуть любые данные в основную программу. Основная программа может возобновить работу Fiber с того места, где она была приостановлена .

Когда вы создадите новый экземпляр Fiber, ничего не произойдет. Коллбек не будет выполняться, до тех пор, пока вы не запустите Fiber. Для запуска используется метод start().

Метод start() передаёт аргументы вызываемому объекту и возвращает всё, что принимает метод suspend().
Метод suspend() возвращает любое значение, которое принял метод resume().
Метод resume() возвращает всё, что принято при следующем вызове suspend().

-----------------------------------------------------------------------------------------------------------------------------------

18. Пример кода.


Рассказать что за чем выполняется.


Вы не будете использовать файберы напрямую
Согласно документации, Fibers предлагает «только минимум, необходимый для того, чтобы пользовательский код мог реализовать корутины с полным стеком или зеленые потоки в PHP».
Некоторые низкоуровневые фреймворки, такие как amPhp и ReactPHP, уже перешли на файберы в своих последних версиях разработки.
Swoole написали статью преимущества и недостатки файберов и чем их корутины лучше файберов и как я понял решили на них не переходить.
Одна из причин это отсутствие каналов, хоть файберы выполняются по одному за раз, все равно может возникнуть ситуация что 1 файбер перепишет информацию, которую расшарил другой файбер. А каналы, которые есть в swoole, решают данную проблему.

-----------------------------------------------------------------------------------------------------------------------------------

19. Конкретных примеров не делал, т.к. это актуально для всех приложений, который работаю с вводом / выводом и делают запросы по API.

Для ларавелевских прилаг лучшим решением будет использовать Laravel Octane. Там все настроено из коробки. Чисто надо поставить PHP дополнение swoole и через composer установить Laravel octane. Еще немного пошаманить с настройками и воркерами да и все.
Все это здорово, но у долгоживующего PHP и асинхронности есть ньюансы. Главные из которых это контроль состояния и утечки памяти. Т.к. PHP теперь не умирает, все что в нем создается, будет жить пока это не убить. Нужно отказаться от классов у которых есть свое внутреннее состояние, т.к. оно будет сохранятся между запросами, а еще нужно убедиться в правильной работе синглтонов. Ну и посмотреть чтобы не было никаких стеков, которые вечно наполняются, а то они рано или поздно переполнятся.  В документации Laravel это все расписано.

Для кейковсих прилагах на самом деле можно любую асинхронную библиотеку использовать, но при использовании Swoole, мы сразу получим прирост производительности, если вынесем инициализацию фреймворка, только надо быть очень внимательными с утечками памяти, фреймворк уже достаточно старый, есть вероятность что может подтекать.
